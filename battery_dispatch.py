# -*- coding: utf-8 -*-
"""
Created on Fri Jul 07 12:23:45 2017

@author: jdkern
"""

#######################################################################################################
# a basic unit commitment model for CAISO system                                                       #
# This is the trial version of the electricity market model                                            #
# 4 Zone system                                                                                        #                                                                                #
#######################################################################################################


from __future__ import division # This line is used to ensure that int or long division arguments are converted to floating point values before division is performed 
from pyomo.environ import * # This command makes the symbols used by Pyomo known to Python
from pyomo.opt import SolverFactory
import itertools

##Create a solver
opt = SolverFactory('cplex')

model = AbstractModel()

# Operating horizon information 
model.Hours = RangeSet(0,17545)
#model.Wind = Param(model.Hours, within=NonNegativeReals)
#model.Target = Param(model.Hours, within=NonNegativeReals)
model.RT_node = Param(model.Hours, within=Reals)
#model.RT_hub = Param(model.Hours, within=NonNegativeReals)
model.MW = Param(within=PositiveIntegers)
model.MWh = Param(within=PositiveIntegers)

###########################################################
### Decision variables                                    #
###########################################################

##Amount of day-ahead energy generated by each thermal unit's 3 segments at each hour
model.discharge = Var(model.Hours, within=NonNegativeReals)
model.charge = Var(model.Hours, within=NonNegativeReals)
model.discharge_on = Var(model.Hours, within=Binary)
model.charge_on = Var(model.Hours, within=Binary)
model.SOC  = Var(model.Hours, bounds=(0,model.MWh),initialize=0)
#
####################################################################
##Objective function                                               #
####################################################################
#
##
def Profits(model):
    revenues = sum(model.discharge[i]*model.RT_node[i] for i in model.Hours)
    costs = sum(model.charge[i]*model.RT_node[i] for i in model.Hours) 
    return costs - revenues
model.SystemProfits = Objective(rule=Profits, sense=minimize)
   
####################################################################
#   Constraints                                                    #
####################################################################
   
#Discharge constraint
def MW_cap1(model,i):
    return model.discharge[i] <= model.MW*model.discharge_on[i]
model.MW_cap1= Constraint(model.Hours,rule=MW_cap1)

#Discharge constraint
def MW_cap2(model,i):
    return model.discharge[i] <=  model.SOC[i]
model.MW_cap2= Constraint(model.Hours,rule=MW_cap2)

#SOC constraint
def SOC_cap1(model,i):
    return model.SOC[i] <=  model.MWh
model.SOC_cap1= Constraint(model.Hours,rule=SOC_cap1)

#SOC constraint
def SOC_cap2(model,i):
    if i == 0:
        return model.SOC[i] == 0
    else:
        return model.SOC[i] == model.SOC[i-1] + 0.8*model.charge[i-1] - model.discharge[i-1]
model.SOC_cap2= Constraint(model.Hours,rule=SOC_cap2)

#Charge constraint
def Charge_1(model,i):
    return model.charge[i] <=  model.MW*model.charge_on[i]
model.charge1= Constraint(model.Hours,rule=Charge_1)

#Mode Constraint
def Mode(model,i):
    return model.discharge_on[i] + model.charge_on[i] <= 1
model.ModeC= Constraint(model.Hours,rule=Mode)

